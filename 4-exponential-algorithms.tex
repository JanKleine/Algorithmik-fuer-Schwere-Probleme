\section{Exakte Exponentialzeit Algorithmen}

\begin{takeaway}
    \item $\bigOstar$-Notation
    \item Branching-Algorithmen: 3-SAT, Max-IS
    \item Dynamische Programmierung: TSP/Held-Karp, Graph Coloring
\end{takeaway}

\paragraph{Motivation}
Entwerfe Algorithmen die zwar exponentiell, aber dennoch schneller als vollständige Suche sind.
Insbesondere in Zeit $c^n$ für $c < 2$ (z.B. $2^{\sqrt{n}} \approx 1.41^n$) anstelle von $2^n$.

\paragraph{$\bigOstar$-Notation}
Idee: so wie wir in $\bigO$-Notation konstanten Faktoren weglassen, lassen wir in $\bigOstar$-Notation
polynomielle Vorfaktoren weg (da der exponentielle Faktor dominiert).

Seien $f,g : \N \mapsto \R^+$. Dann gilt $f(n) \in \bigOstar(g(n))$, falls ein Polynom $p : \N \mapsto \R^+$
existiert, so dass $f(n) \in \bigO(p(n) \cdot g(n))$.


\subsection{Branching-Algorithmen}

\paragraph{Idee}
Instanz der Grösse $n$ aufteilen in konstant viele kleinere Teilinstanzen der Grösse $n-d$, für eine Konstante $d$.
Ähnlich divide-and-conquer.


\subsubsection{Beispiel: 3-SAT}

Annahme: O.B.d.A. hat jede Klausel Literale von paarweise verschiedenen Variablen und alle Klauseln sind
paarweise verschieden, dank polynomiellem preprocessing.
Dann gilt $|\Phi| \in \bigO(n^3)$.

\paragraph{Notation}
Sei $\Phi$ eine Formel in 3-KNF über Variablen $X$, sei $x \in X$, $\alpha \in \setzeroone$.
$\Phi[x=\alpha]$ beschreibt die Formel in 3-KNF, die aus $\Phi$ entsteht indem man den Wert $x=\alpha$ einsetzt
und vereinfacht.

\paragraph{Trivialer Ansatz}
Wähle eine Variable $x$, berechne $\Phi[x=0]$ und $\Phi[x=1]$,
merge ($\Phi$ satisfiable $\iff$ $\Phi[x=0] \text{ satisfiable } \vee \Phi[x=1]$ satisfiable).
Zeit: $T(n) = 2 \cdot T(n-1) + \bigO(n) \implies T(n) \in \bigOstar(2^n) \implies$ keine Verbesserung,
probiert nur alle Belegungen aus.

\paragraph{Branch-3SAT / Monien-Speckenmeyer Algorithmus}
\begin{enumerate}
    \item Falls $\Phi = \emptyset$ return JA
    \item Wähle Klausel $F \in  \Phi$ von minimaler Länge
    \item Falls $F = \emptyset$ return NEIN
    \item Falls $F = (l)$, rufe Branch-3SAT($\Phi[l=1]$) auf
    \item Falls $F = (l_1 \vee l_2)$, rufe Branch-3SAT($\Phi[l_1=1]$) und Branch-3SAT($\Phi[l_1=0, l_2=1]$) auf
    \item Falls $F = (l_1 \vee l_2 \vee l_3)$, rufe Branch-3SAT($\Phi[l_1=1]$) und
    Branch-3SAT($\Phi[l_1=0, l_2=1]$) und Branch-3SAT($\Phi[l_1=0, l_2=0, l_3=1]$) auf
    \item return JA falls einer der rekursiven Aufrufe JA returned, sonst NEIN
\end{enumerate}

\paragraph{Theorem}
Branch-3SAT löst 3-SAT in Zeit $\bigOstar (1.8393^n)$ für alle Formeln über $n$ boolesche Variablen.

\underline{Laufzeit:}
\begin{align*}
T(n) &\leq T(n-1) + T(n-2) + T(n-3) + \bigO(n) \\
T(0) &= T(1) = T(2) = \bigO(n)
\end{align*}
Nehme $T(n) = \alpha^n$ an, forme um nach $\alpha^3 - \alpha^2 - \alpha - 1 = 0$,
finde reale Nullstelle mit $\alpha \in [1,2)$.


\subsubsection{Beispiel: Max-IS}

\paragraph{Maximum Independent Set Problem Max-IS}
\footnote{Recall: maximal == nicht erweiterbar. maximum == grösstes mögliches.} \\
Eingabe: $G=(V,E)$ \\
Lösungen: $\M(G) = \{ S \subseteq \M \st \{ u,v \} \notin E \text{ for all } u,v \in S, u \neq v \}$ \\
Kosten: $cost(S, G) = |S|$ \\
Ziel: $\max$

\paragraph{Algorithmus: Branch-Max-IS}
\begin{enumerate}
    \item if $V = \emptyset$: return $\emptyset$
    \item let $v \leftarrow \min_{u \in V} \deg_G(u)$
    \item let $N[v] = \{ u_1, \dots, u_k \}$ be the \emph{closed} neighbourhood%
    \footnote{Oft nehmen wir o.B.d.A. an dass $u_1 := v$.} of $v$
    \item return the largest set from the family $\{ \{u_i\} \cup \text{Branch-Max-IS}(G-N[u_i]) \st i \in \{1,\dots,k\} \}$
\end{enumerate}

\paragraph{Theorem}
Branch-Max-IS löst Max-IS in Zeit $\bigOstar (3^{n/3})  \subseteq \bigOstar (1.4423^n)$.

\underline{Korrektheit:} Per Konstruktion (wegen Beobachtung dass $\forall v \in V$ mindestens ein $u \in N[v]$ in der optimalen, maximum Lösung enthalten sein muss).

\underline{Laufzeit:}
Ziel: beschränke Anzahl Knoten des Rekursionsbaumes. Es gilt:
$$ T(G) \leq 1 + T(G-N[v]) + \sum_{i=2}^k T(G-N[u_i]) $$
$$ T(n) = \max_{\substack{ G=(V,E) \\ |V|=n}} T(G) $$
%
Ausserdem gilt Monotonie $T(n) \leq T(n+1)$ und $T(0) = 1$. \\
Sei $\delta_{min}(G)$ der minimale Grad in $G$. Es gilt:
%
\begin{align*}
T(G) & \leq 1 + T(n - \delta_G(v) - 1) + \sum_{i=2}^k T(n - \delta_G(u_i) - 1) \\
     & \overset{(1)}{\leq} 1 + T(n - \delta_{min}(G) - 1) + \delta_{min}(G) \cdot T(n - \delta_{min}(G) - 1) \\
     & = 1 + (1 + \delta_{min}(G)) \cdot T(n - (\delta_{min}(G) + 1)) \\
     & \leq 1 + \max_{1 \leq s \leq n} s \cdot T(n - s) \\
T(n) & \overset{(2)}{\leq} 1 + \max_{1 \leq s \leq n} s \cdot T(n - s) \\
\end{align*}
wobei (1) aus der Monotonie folgt.
(2) können wir schreiben, da die rechte Seite nicht mehr von einem bestimmten Graphen $G$ abhängt,
sondern nur noch von der Grösse der Eingabe.

Auflösen dieser letzten Ungleichung siehe Buch Kapitel 5.2, Seite 109f.


\subsection{Dynamische Programmierung}

\paragraph{Travelling Salesman Problem TSP} \mbox{} \\
Eingabe: (O.B.d.A. vollständiger) Graph $G=(V,E)$, Kostenfunktion $c : E \mapsto \N$ \\
Ausgabe: Hamiltonkreis $H$ in $G$ \\
Kosten: $cost(H, G) = \sum_{e \in H} c(e) $ \\
Ziel: $\min$

Problem: $\bigO(n!) = \bigOstar (2^{n \log n})$ viele mögliche Lösungen

\paragraph{Dyn-Prog-TSP / Held-Karp Algorithmus}
{ % space for util command
\newcommand{\vtwon}{\{v_2, \dots, v_n\}}
Für alle $S \subseteq \vtwon$ und jeden Knoten $x \in S$ berechne $l(S, x)$ als die minimalen Kosten
eines Pfades der in $v_1$ startet, in $x \in S$ endet und genau alle Knoten aus $S$ je einmal besucht.

\begin{enumerate}
    \item Initialisierung: $ l(\{v_i\}, v_i) \leftarrow c(\{v_1, v_i\})$ für alle $i \in \{2, \dots n\}$
    \item Für alle $j \in \{2, \dots n-1\}$, für alle $S \subseteq \vtwon$ mit $|S|=j$,
    für alle $x \in S$ berechne:
    $$ l(S, x) \leftarrow \min_{y \in (S-\{x\})} \{ l(S-\{x\},y) + c(\{y,x\}) \} $$
    \item Finde Lösung: $$ l_{min} \leftarrow \min_{v_i \in \vtwon} \{ l(\vtwon,v_i) + c(\{v_i,v_1\}) \} $$
    Return $l_{min}$.
\end{enumerate}
}

\paragraph{Theorem}
Held-Karp löst das TSP in Zeit $\bigOstar (2^n)$.

\underline{Beweis:}
Korrektheit trivial.
Schritte 1 und 3 in $\bigO(n)$.
Schritt 2: $\bigO(2^n)$ viele Teilmengen $S$, für jede wählen wir $x,y$ $\implies \bigO(n^2 \cdot 2^n)$.

\paragraph{Graph Coloring Problem (Graphfärbung)}
Sei $G$ ein ungerichtet, ungewichteter Graph und $k \in \N$.
Eine \emph{k-Färbung (k-coloring)} von $G$ ist eine Funktion $c : V \mapsto \{1, \dots, k\}$ so dass
$$ \{x,y\} \in E \implies c(x) \neq c(y) $$
Die Menge $C_i := \{ x \in V \st c(x) = i \}$ heisst i-te \emph{color class} von $c$.
Die \emph{chromatische Zahl (chromatic number)} $\chi(G)$ von $G$ ist das kleinste $k$ so dass $G$ eine $k$-Färbung besitzt.

Eingabe: $G=(V,E)$ \\
Ausgabe: $\chi(G)$

Bruteforce: $\bigOstar(n^n)$ da $\chi(G) \leq n$

\paragraph{Algorithmus: Dyn-Prog-Coloring}
Beobachtungen:
1) Jeder Farbklasse ist ein independent set in $G$.
2) Wenn $C_i$ kein maximales IS ist, dann existiert ein $x \in V-C_i$ dass zu $i$ umgefärbt werden kann.

\begin{enumerate}
    \item Initialisierung: $\chi(\emptyset) \leftarrow 0$
    \item Für alle $i \in \{1, \dots, n\}$, für alle $X \subseteq V$ mit $|X| = i$ berechne:
    $$ \chi(X) \leftarrow 1 + \min \{ \chi(X-I) \st I \text{ ist ein maximales IS in } G[X] \} $$
    Return $\chi(G) \leftarrow \chi(V)$
\end{enumerate}

\paragraph{Theorem}
Dyn-Prog-Coloring löst das Graphfärbungsproblem in Zeit $\bigOstar(2.4423^n)$.

\underline{Beweis:}
Verwende Variante von Branch-Max-IS\footnote{Betrachtet geschlossene Nachbarschaft aller Knoten, nicht nur
die von minimalem Grad, und gibt alle maximalen IS zurück (nicht nur das grösste).} um in $\bigOstar(3^{i/3})$ alle maximalen IS der Grösse $i$ zu finden.
Insgesamt:
$$ \bigOstar \left(\sum_{i=1}^n \binom{n}{i} \cdot 3^{i/3} \textcolor{gray}{\cdot 1^{(n-i)/3}} \right)
= \bigOstar \left( \left(1+3^{1/3} \right)^n \right) \in \bigOstar \left(2.4423^n \right) $$
unter Anwendung des Binomischen Satzes.

\paragraph{Definitionen (Perfekte Matchings)}
\begin{itemize}
    \item Sei $G$ ein Graph. Ein \emph{perfektes Matching} in $G$ ist eine Menge $\{e_1, \dots e_{n/2}\} \subseteq E$
    paarweiser disjunkter Kanten, die ganz $V$ abdecken: $e_1 \cup \dots \cup e_{n/2} = V$.
    \item Die Anzahl perfekter Matchings in $G$ bezeichnen wir mit $\Pm(G)$.
\end{itemize}




