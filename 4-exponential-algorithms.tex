\section{Exakte Exponentialzeit Algorithmen}

\begin{takeaway}
    \item $\bigOstar$-Notation
    \item Branching-Algorithmen: 3-SAT, Max-IS
\end{takeaway}

\paragraph{Motivation}
Entwerfe Algorithmen die zwar exponentiell, aber dennoch schneller als vollständige Suche sind.
Insbesondere in Zeit $c^n$ für $c < 2$ (z.B. $2^{\sqrt{n}} \approx 1.41^n$) anstelle von $2^n$.

\paragraph{$\bigOstar$-Notation}
Idee: so wie wir in $\bigO$-Notation konstanten Faktoren weglassen, lassen wir in $\bigOstar$-Notation
polynomielle Vorfaktoren weg (da der exponentielle Faktor dominiert).

Seien $f,g : \N \mapsto \R^+$. Dann gilt $f(n) \in \bigOstar(g(n))$, falls ein Polynom $p : \N \mapsto \R^+$
existiert, so dass $f(n) \in \bigO(p(n) \cdot g(n))$.


\subsection{Branching-Algorithmen}

\paragraph{Idee}
Instanz der Grösse $n$ aufteilen in konstant viele kleinere Teilinstanzen der Grösse $n-d$, für eine Konstante $d$.
Ähnlich divide-and-conquer.


\subsubsection{Beispiel: 3-SAT}

Annahme: O.B.d.A. hat jede Klausel Literale von paarweise verschiedenen Variablen und alle Klauseln sind
paarweise verschieden, dank polynomiellem preprocessing.
Dann gilt $|\Phi| \in \bigO(n^3)$.

\paragraph{Notation}
Sei $\Phi$ eine Formel in 3-KNF über Variablen $X$, sei $x \in X$, $\alpha \in \setzeroone$.
$\Phi[x=\alpha]$ beschreibt die Formel in 3-KNF, die aus $\Phi$ entsteht indem man den Wert $x=\alpha$ einsetzt
und vereinfacht.

\paragraph{Trivialer Ansatz}
Wähle eine Variable $x$, berechne $\Phi[x=0]$ und $\Phi[x=1]$,
merge ($\Phi$ satisfiable $\iff$ $\Phi[x=0] \text{ satisfiable } \vee \Phi[x=1]$ satisfiable).
Zeit: $T(n) = 2 \cdot T(n-1) + \bigO(n) \implies T(n) \in \bigOstar(2^n) \implies$ keine Verbesserung,
probiert nur alle Belegungen aus.

\paragraph{Branch-3SAT / Monien-Speckenmeyer Algorithmus}
\begin{enumerate}
    \item Falls $\Phi = \emptyset$ return JA
    \item Wähle Klausel $F \in  \Phi$ von minimaler Länge
    \item Falls $F = \emptyset$ return NEIN
    \item Falls $F = (l)$, rufe Branch-3SAT($\Phi[l=1]$) auf
    \item Falls $F = (l_1 \vee l_2)$, rufe Branch-3SAT($\Phi[l_1=1]$) und Branch-3SAT($\Phi[l_1=0, l_2=1]$) auf
    \item Falls $F = (l_1 \vee l_2 \vee l_3)$, rufe Branch-3SAT($\Phi[l_1=1]$) und
    Branch-3SAT($\Phi[l_1=0, l_2=1]$) und Branch-3SAT($\Phi[l_1=0, l_2=0, l_3=1]$) auf
    \item return JA falls einer der rekursiven Aufrufe JA returned, sonst NEIN
\end{enumerate}

\paragraph{Theorem}
Branch-3SAT löst 3-SAT in Zeit $\bigOstar (1.8393^n)$ für alle Formeln über $n$ boolesche Variablen.

\underline{Laufzeit:}
\begin{align*}
T(n) &\leq T(n-1) + T(n-2) + T(n-3) + \bigO(n) \\
T(0) &= T(1) = T(2) = \bigO(n)
\end{align*}
Nehme $T(n) = \alpha^n$ an, forme um nach $\alpha^3 - \alpha^2 - \alpha - 1 = 0$,
finde reale Nullstelle mit $\alpha \in [1,2)$.


\subsubsection{Beispiel: Max-IS}

\paragraph{Maximum Independent Set Problem Max-IS}
\footnote{Recall: maximal == nicht erweiterbar. maximum == grösstes mögliches.} \\
Eingabe: $G=(V,E)$ \\
Lösungen: $\M(G) = \{ S \subseteq \M \st \{ u,v \} \notin E \text{ for all } u,v \in S, u \neq v \}$ \\
Kosten: $cost(S, G) = |S|$ \\
Ziel: $\max$

\paragraph{Algorithmus: Branch-Max-IS}
\begin{enumerate}
    \item if $V = \emptyset$: return $\emptyset$
    \item let $v \leftarrow \min_{u \in V} \deg_G(u)$
    \item let $N[v] = \{ u_1, \dots, u_k \}$ be the \emph{closed} neighbourhood%
    \footnote{Oft nehmen wir o.B.d.A. an dass $u_1 := v$.} of $v$
    \item return the largest set from the family $\{ \{u_i\} \cup \text{Branch-Max-IS}(G-N[u_i]) \st i \in \{1,\dots,k\} \}$
\end{enumerate}

\paragraph{Theorem}
Branch-Max-IS löst Max-IS in Zeit $\bigOstar (3^{n/3})  \subseteq \bigOstar (1.4423^n)$.

\underline{Korrektheit:} Per Konstruktion (wegen Beobachtung dass $\forall v \in V$ mindestens ein $u \in N[v]$ in der optimalen, maximum Lösung enthalten sein muss).

\underline{Laufzeit:}
Ziel: beschränke Anzahl Knoten des Rekursionsbaumes. Es gilt:
$$ T(G) \leq 1 + T(G-N[v]) + \sum_{i=2}^k T(G-N[u_i]) $$
$$ T(n) = \max_{\substack{ G=(V,E) \\ |V|=n}} T(G) $$
%
Ausserdem gilt Monotonie $T(n) \leq T(n+1)$ und $T(0) = 1$. \\
Sei $\delta_{min}(G)$ der minimale Grad in $G$. Es gilt:
%
\begin{align*}
T(G) & \leq 1 + T(n - \delta_G(v) - 1) + \sum_{i=2}^k T(n - \delta_G(u_i) - 1) \\
     & \overset{(1)}{\leq} 1 + T(n - \delta_{min}(G) - 1) + \delta_{min}(G) \cdot T(n - \delta_{min}(G) - 1) \\
     & = 1 + (1 + \delta_{min}(G)) \cdot T(n - (\delta_{min}(G) + 1)) \\
     & \leq 1 + \max_{1 \leq s \leq n} s \cdot T(n - s) \\
T(n) & \overset{(2)}{\leq} 1 + \max_{1 \leq s \leq n} s \cdot T(n - s) \\
\end{align*}
wobei (1) aus der Monotonie folgt.
(2) können wir schreiben, da die rechte Seite nicht mehr von einem bestimmten Graphen $G$ abhängt,
sondern nur noch von der Grösse der Eingabe.

Auflösen dieser letzten Ungleichung siehe Buch Kapitel 5.2, Seite 109f.











